# Read data {#readdata}

> Prerequisite: Chapter 11 ‘Data Import’ from R for Data Science, available at http://r4ds.had.co.nz/data-import.html

## Introduction to Reading Data

Once you have downlaoded the data from the Understanding Society survey to your computer, the first thing you need to do is read the data into R. There are a number of ways to do this, and this class will cover loading data into R by using base R and both the readr and data.table packages.

The data we will be loading into R is the individual adult questionnaire answers from wave 1 (*UKDA-6614-tab/tab/us_w1/a_indresp.tab*). This should be saved in the *data* folder you created in your project folder (this was covered in the Introduction).

## Reading Data into R

### Using base R

To read this data into R using functions from base R, we can first use the **read.table** function. To read the data in correctly, we need to use **header = TRUE** as the first row of the data contains the names of the variables, and also **stringsAsFactors = FALSE**, which stops R from treating text variables as factors. We can convert these into factors later, when necessary.

```{r cache = TRUE, warning = FALSE, message = FALSE}
UndSoc1 <- read.table("data/UKDA-6614-tab/tab/us_w1/a_indresp.tab",
                      header = TRUE,
                      stringsAsFactors = FALSE)
```

Different types of files need to read into R differently. The **read.table** function reads data that is *tab separated* (the file will be called 'name*.tab*'), the **read.csv** function reads data that is *comma separed* (the file will be called 'name*.csv*') and **read.delim** reads data that is separated in any way. These work in the same way, so once you've mastered one, you've mastered them all.

### Using the readr package

We can also read data into R using the package *readr*, part of the *tidyverse* package, with the **read_tsv** command. This is the equivalent command to **read.table** from base R.

```{r cache = TRUE, warning = FALSE, message = FALSE}
# We can either load the entire 'tidyverse' package into R, which includes the readr package as well as others such as ggplot2, or just the 'readr' package on its own.

library(readr)

UndSoc2 <- read_tsv("data/UKDA-6614-tab/tab/us_w1/a_indresp.tab")
```

The readr package also allows us to read different types of files into R. The commands **read_csv** and **read_delim** read comma and any type of separated data into R respectively.

### Using the data.table package

The final way we are going to read this data into R is by using the **fread** function from the **data.table** package. The advantage of the **fread** command is that it can read any type of separated data into R, without you having to change anything if the file type you are trying to read changes.

```{r cache = TRUE, warning = FALSE, message = FALSE}
library(data.table)

UndSoc3 <- fread("data/UKDA-6614-tab/tab/us_w1/a_indresp.tab")
```

### Comparing these three methods

One of the important differences between these three methods for reading data into R is the length of time they take to read the data. We can compare this by reading the data into R again, this time wrapping our code with the command **system.time**.

#### Using base R

```{r cache = TRUE, warning = FALSE, message = FALSE}
# Base R
system.time(UndSoc1 <- read.table("data/UKDA-6614-tab/tab/us_w1/a_indresp.tab",
                      header = TRUE,
                      stringsAsFactors = FALSE))
```

It takes about 23 seconds to read the data into R using this method.

#### Using the readr package

```{r cache = TRUE, warning = FALSE, message = FALSE}
system.time(UndSoc2 <- read_tsv("data/UKDA-6614-tab/tab/us_w1/a_indresp.tab"))
```

It takes only 5 seconds to read the data into R using this method.

#### Using the data.table package

```{r cache = TRUE, warning = FALSE, message = FALSE}
system.time(UndSoc3 <- fread("data/UKDA-6614-tab/tab/us_w1/a_indresp.tab"))
```

It takes just 3 seconds to read the data into R using this method, a whole 20 seconds quicker than using the commands from base R!

From this we can see clear differences in loading time. With small data sets, the difference between these three methods will not be very noticeable or important, but with larger data the increase in loading times **readr** and **data.table** provide can be quite substantial.

### Skipping rows of data

Sometimes we do not want to read in the entire dataset we have into R, but instead want to ignore the first few rows. For example, if we were to do some sentiment analysis on Hamlet (found here: http://www.gutenberg.org/cache/epub/2265/pg2265.html), we would want to only download the play itself, not the introductions before the start of the play. Once we've saved the play as a *.txt* file in our data folder, we can use the **skip** command to only read the file from a certain point.

```{r cache = TRUE, warning = FALSE, message = FALSE}
Hamlet <- read.delim("data/Hamlet.txt",
                     skip = 331,
                     header = FALSE)
```

### Reading only select variables

When working with large datasets, like the one you will be using for your assignment, there are only certain variables that are of interest. As a result, it makes sense to only load these variables in, to make analysing your data easier to do.

Let's say that we're interested in how political interest is distributed across the UK, and want to analyse how this is differentiated by sex, age and net monthly income. The variables we need to read into R are these three (*a_sex*, *a_dvage* and *a_fimnnet_dv*), as well as interest in politics (*a_vote6*) and the personal identification variable for each individual (*a_pidp*). We can use the **select** command to do this.

```{r cache = TRUE, warning = FALSE, message = FALSE}
UndSoc4 <- fread("data/UKDA-6614-tab/tab/us_w1/a_indresp.tab",
                 select = c("pidp", "a_sex", "a_dvage", "a_fimnnet_dv", "a_vote6"))
```

### Setting *NA* values

Sometimes, if we look at the raw data we are about to analyse, we see that there are a number of missing values. Instead of recoding these values as *NA* after we have loaded our data (found, in this example, at https://raw.githubusercontent.com/abessudnov/dataanalysis3/master/exData/Table3.txt), we can do this while reading our data into R using the **na.strings** command.

```{r cache = TRUE, warning = FALSE, message = FALSE}
MissingData <- read.table("data/MissingData.txt",
                 header = TRUE,
                 skip = 2,
                 na.strings = c('*', '**', '--'))
```

## Reading other data files

In R, you can also read data that was created in SPSS or Excel. Excel files are saved primarily as *.xls* or *.xlsx* files. Fortunately, after installing the **readxl** package, the command **read_excel** can read both formats into R. Using the example Excel document found at (https://github.com/abessudnov/dataanalysis3/blob/master/exData/tableExcel.xlsx), we can easily read this into R.

```{r cache = TRUE, warning = FALSE, message = FALSE}
library(readxl)

Excel <- read_excel("data/tableExcel.xlsx")
```

When reading Excel files into R, **read_excel** defaults to loading the first sheet. If there are multiple sheets in our document (by opening the Excel file we can see that there are 2 in this case), we can load different sheets in with the **sheet** command.

```{r cache = TRUE, warning = FALSE, message = FALSE}
Excel2 <- read_excel("data/tableExcel.xlsx",
                     sheet = 2)
```

However, if we look at the sheet we have just loaded, we can see that there are two *NA* values, one of which is coded as *"NA"*. Furthermore, if we compare how these *NA* values appear in our data with the ones from our *MissingData* dataset, we can see that they aren't actually coded as missing values, but instead as values called *NA* and *"NA"*.

```{r cache = TRUE, warning = FALSE, message = FALSE}
head(MissingData)

head(Excel2)
```

To fix this, we need to set both these values as *NA*, which we can do with the **na** command.

```{r cache = TRUE, warning = FALSE, message = FALSE}
Excel3 <- read_excel("data/tableExcel.xlsx",
                     sheet = 2,
                     na = c('NA', '"NA"'))
```

We can now see that this dataset has true *NA* values in it for the missing data.

```{r cache = TRUE, warning = FALSE, message = FALSE}
head(Excel3)
```

## Saving datasets

Once you have read your data into R you can save it as R workspace.


# I will remove some objects from memory to speed things up
rm(UndSoc2, UndSoc3)
# saving R workspavce now in myData (you need to create myData first)
save.image("myData/readTest.RData")


### Dropping variables

Next time I need this file I can simply load the workspace.

``{r cache = TRUE}
# first let's remove everything from the workspace
rm(list = ls())
# load the workspace
system.time(load("myData/readTest.RData"))
```

Of course, in R workspace you can save not only data frames but any objects: models, plots, functions, etc.