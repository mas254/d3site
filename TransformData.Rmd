# Transform data {#transformdata}

> Prerequisite: Chapter 11 'Data transformation' from R for Data Science, available at http://r4ds.had.co.nz/transform.html

## Introduction to transforming data

Once you have imported your data in R you will usually want to clean it, transform it and produce some data summaries. All these tasks can be accomplished with base R. However, it is usually more convenient to use specialised packages for this, such as **dplyr** and **data.table**. In this module we will use **dplyr**.

We are going to work with wave 1 from the Understanding Society dataset.

```{r cache = TRUE}
# First, install the 'data.table' package.

library(data.table)

# Revisit the class "Read Data" if you need a reminder on how to best read data into R.

W1 <- fread("data/UKDA-6614-tab/tab/us_w1/a_indresp.tab")
```

## Operators recap

However, before we learn how to transform data in R, we are going to recap on operators you will need that you should have covered in other courses using R. These operators are *relational* and *logical*.

### Relational operators

Relational operators are used when comparing values, and will help with selecting cases, recoding and creating variables in your assignment. Below is a table with some useful relational operators available in R.

Operator | Description
-------- | -----------
< | Less than
> | Greater than
<! | Not less than
>! Not greater than
<= | Less than or equal to
>= | Greater than or equal to
== | Equal to
!= | Not equal to

For example, if we code *x* to be 5 and *y* to be 6, we can use these operators to compare the two. R gives us a *TRUE* or *FALSE* reading for each comparison we make.

```{r cache = TRUE}
x <- 5

y <- 6

x < y

x == y

x != y
```

If we were selecting variables from a data frame that were greater than *x*, for example, we could use these operators to do so. This will be covered later in this class.

### Logical operators

Logical operators are used to help comparing values, and are especially useful when comparing multiple values. Below is a table of some useful logical operators available in R.

Operator | Description
-------- | -----------
& | And
```|``` | Or

```{r cache = TRUE}
z <- 7

x & y < y

x | z < y

x | z <! y
```

Again, these operators will be used more later in this class, and are necessary when recoding values.

```{r chache = TRUE}
# Cleaning up the working environment.

rm(x, y, z)
```

## The pipe operator (%>%)

The first step in transforming data is understanding what the pipe operator *%>%* is, and how it works. To do this, we are going to create a simple table showing the proportions of responses given to the variable *political interest* (**a_vote6**). To begin with, we create a table showing the numbers of responses given for each category.

```{r cache = TRUE}
table(W1$a_vote6)
```

To convert this table into a table of proportions we do the following.

```{r cache = TRUE}
prop.table(table(W1$a_vote6))
```

To print this table in an easy-to-read manner, we would usually use the **kable()** function from the *knitr* package, and would need to convert the table into a data frame first and then apply the function **kable()**.

```{r cache = TRUE}
# Loading the 'knitr' package into R.

library(knitr)

# Printing the table of proportions.

kable(data.frame(prop.table(table(W1$a_vote6))), digits = 2)
```

As you can see, at this point we have four 'nested' functions (functions within other functions) and the code becomes difficult to read. With the pipe operator **%>%** (Shift+Ctrl+M on Windows or Shift+Cmd+M on Mac) you can achieve the same result with the following code.

```{r cache = TRUE}
# Loading the 'tidyverse' package, from which the package containing the pipe operator ('dplyr') is stored.

library(tidyverse)

W1$a_vote6 %>%
  table() %>%
  prop.table() %>%
  data.frame() %>%
  kable(digits = 2)
```

The pipe operator passes the results of the execution of a function to the next function, essentially treating the entire chunk of code as a ladder, which is executed from top to bottom, with each extra line of code being run on the results from the previous line. This makes code easier to write, read and understand.

## Select variables

For your assignment, you will only want to work with select variables from Understanding Soceity. You learnt how to read in only select variables from a dataset in the *Read data* class, though if you have already loaded in a dataset (as we have here) and want to select only certain variables from this, you need to learn how to transform the data as you do not want to have to keep loading data in to R every time you decided to add or remove a variable from your analysis.

Here, we will select the variables for sex, age, place of birth and measures of weight and height, as well as the personal identification variable for each individual. In base R you could use the following code:

```{r cache = TRUE}
newW1 <- subset(W1, select = c("pidp", "a_sex", "a_dvage", "a_ukborn", "a_hlht", "a_hlhtf", "a_hlhti", "a_hlhtc", "a_hlwt", "a_hlwts", "a_hlwtp", "a_hlwtk"))
head(newW1, 3)
```

However, with **dplyr**, we are able to do this with much less code, as follows.

```{r cache = TRUE}
newW1 <- W1 %>%
  select(pidp:a_dvage, a_ukborn, a_hlht:a_hlwtk)
head(newW1, 3)
```

As some of the variables we want to select from the *W1* data appear next to one another, we can use a colon to select variables next to one another, meaning we do not need to write out every variable we want to select.

```{r cache = TRUE}
# Clearing W1 from the working environment.

rm(W1)
```

## Select cases

Relatedly, sometimes you will want to only work with certain cases in variables that meet certain conditions. Here, we only include women aged 18 to 25 in a new data frame. To do this in base R, we use what we recapped in *Operators recap* and can save the new data frame as follows.

```{r cache = TRUE}
women <- newW1[newW1$a_sex == 2 & (newW1$a_dvage >= 18 & newW1$a_dvage <=25),]
```

Once again, by using  **dplyr**, our code will shorter and easier to read.

```{r cache = TRUE}
newW1 %>%
  filter(a_sex == 2 & (a_dvage >= 18 & a_dvage <=25)) %>%
  head(3)

# Note: We are not saving the new data frame as an object and instead print the first three rows from the data to demonstrate the result.
```

We can make this as complicated as we want and use more than one variable. For example, here is a new data frame that includes only people born in Wales or Northern Ireland *and* over the age of 40.

```{r cache = TRUE}
newW1 %>%
  filter((a_ukborn == 3 | a_ukborn == 4) & a_dvage > 40) %>%
  head(3)
```

## Recode variables Both base R and dplyr using ifelse 

Wanting to change the output of variables is common when working with data, as variables are often coded in ways that make them easy to code for those recording the variables, but difficult to understand without a code book for people analysing the data. This is the case with some of the variables in Understanding Soceity.

If you look at the code book for Understanding Society, you can see that the variable *ukborn* is coded to give numerical values that correspond to a country of birth. To make interpreting this variable easier, both for us and for anyone reading our analysis of the Understanding Society data, we can recode this variable to instead show the country name, rather than a numerical value, as its output.

```{r cache = TRUE}
# Instead of recoding the variable and overwriting the original, we create a new variable to put the recoded variable in, as if we make a mistake with our code and have overwritten the original data, we will have to reload the dataset and start this process again. It is good coding practice to never overwrite original data.

newW1$a_uk <- ifelse(newW1$a_ukborn == 1, 'England',
                     ifelse(newW1$a_ukborn == 2, 'Scotland',
                            ifelse(newW1$a_ukborn == 3, 'Wales',
                                   ifelse(newW1$a_ukborn == 4, 'NIR',
                                          ifelse(newW1$a_ukborn == 5, 'Overseas',
                                                 NA)))))
```

EXPLAIN: USING IFELSE WORKS WITH VARIABLE ==, NEW OUTPUT, IF NOT == THEN DO THIS

Once again, however, **dplyr** makes this process shorter to write and easier to read.

## Create new variables

Relatedly...

Let us create a new dummy variable *scotland* that takes the value of 1 if a person was born in Scotland and 0 otherwise.

I will not show you how to do this in base R (I assume you know this already) and will focus on **dplyr**.

```{r}
newW1 %>%
  mutate(scotland = ifelse(a_ukborn == 2, 1, 0)) %>%
  head(3)
```

Here I use the function **ifelse** that evaluates a condition that *a_ukborn == 2* and returns 1 if this is true and 0 if this is false.

Now let us imagine we want to code a variable for the place of birth converting numeric values into text and coding missing values as NA.

```{r}
newW1 %>%
  mutate(placeBirth = recode(a_ukborn,
                             "1" = "England",
                             "2" = "Scotland",
                             "3" = "Wales",
                             "4" = "Northern Ireland",
                             "5" = "not UK",
                             .default = NA_character_)) %>%
  head(3)
```

*.default = NA_character_* codes all the values that were not specifically matched (all negative values in our case) to missing values.

We can compare the distributions of the original and recoded variables to make sure that everything is correct.

```{r}
newW1 %>%
  mutate(placeBirth = recode(a_ukborn,
                             "1" = "England",
                             "2" = "Scotland",
                             "3" = "Wales",
                             "4" = "Northern Ireland",
                             "5" = "not UK",
                             .default = NA_character_)) %>%
  count(a_ukborn, placeBirth)
```

Now let us have a slightly more complicated case. We may want to code a variable for the body mass index (BMI) which is defined as weight in kilograms divided by the square of height in meters:

$$BMI = \frac{weight_{kg}}{{height_{m}}^2}$$

The problem is that in our data set some people gave their weight in kilograms (*a_hlwtk*) and some in stones and pounds (*a_hlwts* and *a_hlwtp*). Similarly, some people gave their height in centimeters (*a_hlhtc*) and others in feet and inches (*a_hlhtf* and *a_hlhti*). We need to start with converting the measures for everyone to kilograms and centimeters and then we will be able to create a variable for BMI.

These are the formulas for conversion:

1 feet = 30.48cm
1 inch = 2.54cm
 
1 stone = 6.35kg
1 pound = 0.45kg

```{r}
W1mod <- newW1 %>%
  # create a variable for height in cm
  # if height is measured in feet and inches (a_hlht == 1) and is not missing (a_hlhtf > 0),
  # convert it to centimeters
  # otherwise if it is already measured in cm (a_hlht == 2) leave as it is
  # if a_hlht is neither 1 nor 2 code it to missing
  mutate(heightcm = ifelse(a_hlht == 1 & a_hlhtf > 0, 
                           a_hlhtf*30.48 + a_hlhti*2.54,
                           ifelse(a_hlht == 2 & a_hlhtc > 0, 
                                  a_hlhtc, NA))) %>%
  # now same with weight
  mutate(weightkg = ifelse(a_hlwt == 1 & a_hlwts > 0, 
                           a_hlwts*6.35 + a_hlwtp*0.45,
                           ifelse(a_hlwt == 2 & a_hlwtk > 0, 
                                  a_hlwtk, NA))) %>%
  # now create a variable for BMI
  mutate(bmi = weightkg / (heightcm / 100)^2)

```

Let us now look at the distribution of BMI.

```{r}
hist(W1mod$bmi)
```

## Sort data

We can sort data with **arrange**.

We may want to sort the data by BMI.

```{r}
W1mod %>%
  arrange(bmi) %>%
  select(pidp, bmi) %>%
  head(5)
```

We can also sort cases by BMI in the decreasing order, separately for each sex.

```{r}
W1mod %>%
  arrange(a_sex, desc(bmi)) %>%
  select(pidp, a_sex, bmi) %>%
  head(5)
```